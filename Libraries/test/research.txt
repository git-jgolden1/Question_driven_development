Introduction

The title of this book is the punch line of an old joke that goes like this: Joe is a very nice fellow, but has always been a little slow. He goes into a store where a salesman is standing on a soapbox in front of a group of people. The salesman is pitching the miracle new invention, the Thermos bottle. He is saying, "It keeps hot food hot, and cold food cold...." Joe thinks about this a minute, amazed by this new invention that is able to make a decision about which of two different things it is supposed to do depending on what kind of food you put in it. He can’t contain his curiosity, he is jumping up and down, waving his arm in the air, saying “but, but, but, but…” Finally he blurts out his burning question "But how do it know?" You may or may not have laughed at the joke, but the point is that Joe looked at what this Thermos bottle could do, and decided that it must be capable of sensing something about its contents, and then performing a heating or cooling operation accordingly. He thought it must contain a heater and a refrigerator. He had no idea of the much simpler principle on which it actually operates, which is that heat always attempts to move from a hotter area to a cooler area, and all the Thermos does is to slow down this movement. With cold contents, the outside heat is slowed on its way in, and with hot contents, the heat is slowed on its way out. The bottle doesn't have to "know" in order to fulfill its mission, and doesn't heat or cool anything. And eventually, the contents, hot or cold, do end up at room temperature.  But Joe's concept of how the bottle worked was far more complicated than the truth.

So the reason for the book title, is that when it comes to computers, people look at them, see what they can do, and imagine all sorts of things that must be in these machines. Or they imagine all sorts of principles that they must be based on, and therefore what they may be capable of. People may assign human qualities to the machine. And more than a few find themselves in situations where they feel that they are embarrassing themselves, like our friend in the joke, Joe.

But computers are actually quite easy to understand. Of course computers have a greater number of parts than a Thermos bottle, but each part is extremely simple, and they all operate on a very simple, very easy to understand principle.  With the Thermos, the principle is that of the motion of heat. This is something we can observe in life. We see ice cubes melting when they are removed from the freezer, and we see the hot meal cooling off on the table when the family is late for dinner.  In the computer, the principle on which it operates has to do with electricity, but that doesn't mean that it is hard to understand. If you have observed the fact that when you turn on a light switch, a light bulb lights up, and when you turn the switch off, the light goes dark, then you have observed the principle on which computers operate. That is about all you need to know about electricity to understand computers.  7 Just the Facts Ma’am This book is not primarily intended to be a textbook.  There are no problems to do at the end of each chapter.  Its intention is simply to demystify the subject of computers for anyone who has ever wondered what’s going on inside of that box. Of course, it also makes a perfect introduction to computers for a young person who will ultimately go on to get a PhD in Computer Science.  But it should be easily understandable by housewives, senior citizens and children who can read well. It should be understandable to plumbers and street sweepers. It requires no previous technical education.  It only requires that you can read the language, you can turn a light bulb on and off, and you can do very simple addition on the order of 8+5=13.  This book presents the complete essentials that make up a computer. It presents every piece and part, in the proper order so that each one will make sense, and can be understood. Every part is explained fully, and every new word is defined thoroughly when it is first used.  Any attempt to simplify the subject further would leave gaps in the big picture where someone would still have to guess how the parts work together, and you just wouldn’t ever have that “Aha, I get it!” moment that I think you’ll soon have.  This book is not a ‘dumbed-down’ version of some college textbook. It is a complete explanation of the basic principles of computers. It is a technical book, but so is a cookbook and so is a driver’s education handbook.  This book just starts at the beginning and defines every item needed to understand the machine. No matter what someone already knows about computers, this will fill in any missing pieces and put them all together into something that makes sense.  Even our friend, Joe, could understand this book with diligent study. There are thousands of words and ideas associated with the field of computers that make the whole subject seem like a mess. But the basic concepts underlying them are simple.  In this book, there will not be volumes of trivia about 8 the construction or history of computers, just the essentials, no more and no less. Each part of the computer has a simple function, and when they are connected together, you end up with a useful machine called a computer.  There is nothing to memorize in this book. Each chapter is designed to give you a new idea that you didn’t have before, or if it is something that you had heard about previously, it always seemed confusing. Each idea is very simple, and one thing leads to the next. Each chapter presents an idea. Each idea is simple and easy to understand. Later chapters present ideas that build on the ideas from previous chapters.  If someone were to write a book about how to build a house, there could be various levels of detail. The simplest book would say, “lay a foundation, put up the walls, cover with a roof, put in plumbing and electrical, and you’re done.” That would not be enough detail for someone who didn’t already have some experience using a hammer and saw and installing a faucet and wiring a light switch.  At the other end of the spectrum would be a book that had separate chapters for every possible type of foundation, the different kinds of dirt you might have to dig in, formulas for a dozen different kinds concrete, charts of weather conditions that are optimum for laying foundations, etc. That would be far too much information. There would be so many details, that what was really important would get lost.  This book attempts to give just enough detail to see what every computer has in common and how they work, not how to build the biggest or best computer ever made. It is not about any specific brand of computer. It is not about how to use a computer. If it were a book about building a house, it would probably describe a simple plan for a sturdy garden shed with a sink and one bare light bulb, showing the size and shape of every piece of wood, where to put all the nails, how to hang the door and how to put the water pipes together so they wouldn’t leak. It would not show how to build anything as complicated as a fancy curved oak staircase.  We are going to show the one simple part that computers 9 are made of, and then connect a bunch of them together until we have built a complete computer. It is going to be a lot simpler than you ever imagined.  10 Speed Computers seem mysterious and magical. How can they do what they do? They play games, they draw pictures, they 'know' your credit rating. These machines are capable of doing all sorts of strange and wondrous things. Yet they are simple. They can do only a very few, very simple things. And, they can only do one of these simple things at a time. They appear to be doing complex things, only because they do a huge number of simple things one after another in a small amount of time. The result, as in a video game, is very complex in appearance, but in reality, is very simple, just very very fast.  Computers are designed to do a small number of specific simple things, and to do these things quickly, one after the other. Which simple things are done, and in what order, determines what sort of task the computer accomplishes in any given time, but anything the computer does consists of nothing outside of its limited capabilities.  Once you see what a computer is made up of, you will come to realize how it is that they can do what they do, exactly what sorts of things they are capable of, and also, what they are not capable of.  So the secret of computers is not that they are complex, rather it is their speed. Let’s look at exactly how fast their speed is.  Since computers work on electricity, their speed is related to the speed of electricity. You may remember hearing that the speed of light is 186,000 miles per second. That’s pretty darned fast. Light can go around the entire earth seven times in one second, or from the Earth to the Moon in about a second and a half. Per the physicists, electricity has many properties in common with light, and its speed, when traveling in a wire, gets slowed down to about half the speed of light. But still, going all the way around the Earth three and a half times in one second is extremely fast.  As a point of comparison, imagine it is a hot day and you have an electric fan sitting on the table blowing 11 cool air on you. The fan is spinning around so fast that the blades are a blur, but it is only spinning around about 40 times each second. A point on the edge of one of those blades will only travel about 150 feet in that second, it will take 35 seconds for that point to travel just one mile.  Since the fan blades are already a blur, it may be hard to imagine them going just ten times faster. If it did, that fan would be putting out quite a breeze. And if you could make it go a hundred times faster, it would almost certainly self-destruct, with fan blades breaking off and getting stuck in the ceiling. But electricity traveling in the same circle would go around about a hundred million times in one second, that’s two and a half million times faster than the fan blades. That’s fast.  A million is a very large number. If you took a big sheet of paper that was 40 inches square and took a ruler and placed it at the top edge, and drew 25 dots per inch along the top edge of the paper, you would have to draw one thousand dots to get across that sheet of paper. If you then moved the ruler down the page 1/25 th of an inch, and drew another thousand dots, and kept doing that, you would have to move the ruler down the page one thousand times, each time drawing one thousand dots. If you could complete such a boring task, you would end up with a piece of paper with a million dots on it. That’s a lot of dots or a lot of anything. And just to finish the thought, if you could find a thousand people who would each draw one of these million dot sheets, and stacked up those thousand sheets in a pile, you would then have a billion dots.  Now let’s say that the electricity moving around inside the computer can accomplish some simple task by traveling one foot. That means that the computer could do 500 million simple things in one second. Again for comparison, the fan on the table will spin for 7 hours to go around just one million times and it will take a full six months for it to spin around 500 million times.  When you talk about the speed that electricity can move between parts inside the computer, some of the parts you can see are a foot apart, some are closer, an inch, a 12 tenth of an inch. And inside these parts are a multitude more parts that are very close to each other, some just thousandths of an inch apart. And the shorter the distance the electricity has to travel, the sooner it gets there.  There is no point in saying how many things today’s computers do in a single second, because that would date this book. Computer manufacturers continue to produce new computers that go twice as fast as the fastest computers of only two or three years past. There is a theoretical limit to how fast they can go, but engineers keep finding practical ways to get around the theories and make machines that go faster and faster.  During all of this time that computers have been getting faster, smaller and cheaper, the things that computers do, really have not changed since they were first invented in the 1940's. They still do the same few simple things, just faster, cheaper, more reliably and in a smaller package.  There are only a few sections to a computer, and they are all made out of the same kinds of parts. Each section has a specific mission, and the combination of these parts into a machine was a truly marvelous invention. But it is not difficult to understand.  13 Language In this book, we are going to need to define some words that are used to describe the parts inside a computer.  In some professions, notably the Medical and Legal, there is a tendency to make up a lot of new words, and to take them from the ancient Greek and Latin languages, and to make them long and hard to pronounce.  In the world of computers, it seems that the pioneer inventors were a less formal sort of people. Most of the words they used are simple words from everyday language, words that already existed, but are used in a new way.  Some of the new words are words we already know, used as a different part of speech, like an existing noun now used as a verb. Some of the words are acronyms, the first letters from the words of a phrase.  Each word will be described thoroughly when it is first used. And although there are thousands of words and acronyms in use if you consider the entire computer industry, there are only about a dozen or two words needed to understand the computer itself. You have probably heard some of these words before, and figured out what they meant from how they were used, but now you will get the proper and full definitions. In many cases you may find that they are simpler than you thought.  14 Just a Little Bit What is in a computer? It shows you still pictures, moving pictures, music, your checkbook, letters you have written, it plays video games, communicates all around the world, and much much more. But are there pictures inside the computer? If you got out a microscope and knew where to look, could you find little pictures somewhere inside the computer? Would you see “A”s and “B”s and “8”s and “12”s moving around in there somewhere?  The answer is no, there are no pictures, numbers or letters in a computer. There is only one kind of thing in a computer. There are a large number of this kind of thing, but there is only one kind of thing in there. It is called a bit.  When you flip a coin up in the air, and let it fall on the ground, it will end up on the floor in one of two possible states - with either the head showing, or the tail.  The light in your living room (assuming you have a switch and not a dimmer) can be either on or off.  The lock on your front door can be either locked or unlocked.  What do all of these things have in common? They are all places that contain a thing that can be in one of two possible states. This is the definition of a bit.  A bit is some kind of a physical object that has a size and a location in space, and it has some quality about itself, that at any given time can be in one of two possible states, and may be made to change back and forth between those two states.  A lump of clay is not a bit. It can be molded into a ball, a cube, a pancake, a ring, a log, a face or anything else you can think of. It has a size and a location in space, but there are too many states that it can be in for it to be called a bit. If you took that lump of clay, flattened it out, scratched “yes” on one side of it, and “no” on the other side, and then put it in a kiln and fired it until it was hard, then you might 15 be able to call it a bit. It could sit on a table with either the “yes” or “no” showing. Then it would only have two states.  You have probably heard of bits before in relation to computers, and now you know what they are. In a computer, the bits are not like the coin or the lock, they are most like the light. That is, the bits in a computer are places that either have electricity or they do not. In a computer, the bits are very, very small and there are a very large number of bits, but that’s all that is in there.  Like the light in the living room, the bit is either on or off. In the living room, there is electricity in the wall coming into the switch. When you turn the switch on, the electricity goes from the switch, through the wires in the wall and ceiling, into the light socket and then into the light bulb. So this bit in the living room is several feet long, it includes the switch, the wires, the socket and the light bulb. In a computer, bits are mostly tiny, actually microscopic. Also, the computer bit doesn’t have a mechanical switch at one end or a light bulb at the other. If you removed the light bulb from the socket in the living room, the switch would still send electricity to the socket when it was on, and it would still be a bit – you just wouldn’t be able to see whether it was on or off by looking at a light bulb.  Your computer has something resembling switches, like the keys on the keyboard, and something resembling light bulbs, like the tiny dots on the screen, but most of the bits are inside and unseen.  This is basically all there is in a computer – bits.  There are lots and lots of them, and they are arranged and connected up in various ways, which we will examine in detail as the book progresses, but this is what is inside all computers – bits. A bit is always in one of its two possible states, either off or on, and they change between on and off when they are told to do so.  Computer bits aren’t like the coin that has to physically flip over to change from one state to the other. Bits don’t change shape or location, they don’t look any different, they don’t move or rotate or get bigger or smaller. A computer bit is just a place, if there is no electricity in that place, then the bit is 16 off. When electricity is present, then the bit is on.  If you want to change a coin from showing heads to showing tails, you have to physically move it to flip it over, which takes some amount of time. Because the only thing that has to move in a computer bit is the electricity, changing it’s state from off to on, or on to off can happen much more quickly than anything that has to be moved physically.  As another example, remember the wild American west from the movies? There were little towns separated by vast distances. The bigger towns would have a telegraph office. In this office was a guy wearing a funny hat who had a spring-loaded switch called a key, and he would send messages by pressing this key on and off in certain patterns that represented the letters of the alphabet.  That key was connected to a battery (yes they had batteries back then) and a wire that was strung along poles until it got to another town. The key simply connected the battery to the wire when it was pressed, and disconnected the battery when the key was not pressed. In the other town there was another telegraph office, the wire came into that office, the end of it was wrapped around an iron rod (which turns into a magnet when there is electricity in the wire,) the magnetized rod attracted a little bar of iron held nearby with a spring, and made a clicking sound every time the electricity came on. The guy in the office listened to the pattern of the clicking and wrote down the letters of the message. They might have used a light bulb instead of the clicker, except that light bulbs had not yet been invented.  The point of bringing up this subject, is that this whole telegraph machine, from the key that gets pressed in one town, through the long wire that travels to another town many miles away, to the clicker, this whole apparatus comprises just one single bit. It is a place that can either have or not have electricity, and goes on and off as it is told. And this method of communication revolutionized the world in many ways. But this very important invention of the 1840s consisted of nothing more than one bit.  So I hope this begins to simplify the subject of 17 computers for you. There is only one thing inside computers, bits. Lots of them to be sure, but when you understand bits, you understand what’s in there.  18 What the…?  Imagine it is a bright sunny day, and you walk into a room with lots of open windows. You notice that the ceiling light is on. You decide that this is a waste, and you are going to turn the light off. You look at the wall next to the door and see a switch plate with two switches. So you assume that the one closer to the door is for the ceiling light. But then you notice that the switch is already off. And the other switch is off too.  So then you think “well, maybe someone installed the switch upside down,” so you decide to flip the switch anyway. You flip it on and off but nothing happens, the ceiling light stays lit. So then you decide that it must be the other switch, and you flip it on, off, on, off.  Again nothing happens, that ceiling light continues to shine at you. You look around, there is no other door, there are no other switches, no apparent way to turn off this darned light. It just has to be one of these two switches, who built this crazy house anyway? So you grab one switch with each hand and start flipping them wildly. Then suddenly you notice the ceiling light flicker off briefly. So you slow down your switch flipping and stop when the ceiling light is off. Both switches say “on”, and the light is now off. You turn one switch off, then on, and the light goes on, then back off. This is backwards. One switch off equals light on? So then you turn the other switch off, then on, the same thing, the light goes on, then back off. What the heck? Anyway, you finally figure out how it works. If both switches are on, the light goes off. If one or the other or both switches are off, then the ceiling light is on. Kind of goofy, but you accomplish what you intended, you turn both switches on, the light goes off, and you get the heck out of this crazy room.  Now what is the purpose of this little story about the odd light switches? The answer is, that in this chapter we are going to present the most basic part that computers are made of. This part works exactly like the lighting system in that strange room.  This computer part is a simple device that has three connections where there may or may not be some 19 electricity. Two of those connections are places where electricity may be put into the device, and the third connection is a place where electricity may come out of the device.  Of the three connections, two of them are called “inputs,” because electricity can be sent to them from somewhere else. The third connection is called the “output” because electricity can come out of it and then be sent somewhere else.  This computer part is a device that does something with bits. If you have two bits, and you connect those two bits to the inputs, this device “looks” at those two bits, and “decides” whether to turn the one output bit on or off.  The way it “decides” is very simple, and is always the same. If both inputs are on, the output will be off. If one or both of the inputs are off, then the output will be on. That’s just the way that the room with the odd light switches worked.  Remember that there is nothing but bits inside the computer. This simple device is where bits come from and where they go to. The “decision” that this device makes is how bits come to be turned on and off in a computer.  Two bits go into the device, and one bit comes out. Two bits come from somewhere else, are examined by the device, and a new third bit is generated so that it may go somewhere else.  If you have been extra observant, you may have asked yourself this question: “when both inputs are off, the output is on, so…. how do you get electricity at the output if both inputs are off?” Well, that is an excellent question, and the excellent answer is that every one of these devices is also connected to power.  Like every appliance or table lamp in your house, where each has a plug with two pins, this device has a pair of wires, one of which is connected to a place where the electricity is always on, and the other is connected to a place where the electricity is always off. This is where the electricity for the output comes from. When someone builds a computer, they have to make all of those power connections to each one of those parts in order to have it work, but when we are drawing diagrams 20 of parts, how they are connected, and what they will do, we won’t bother drawing the power wires – they would just clutter up the drawing. It is understood that each part has its power connection, and we don’t worry about it. Just understand that it is there, and we won’t mention it any more for the rest of the book. I wouldn’t have even mentioned it here except that I figured that you’d probably ask yourself that question sooner or later.  Now I know I said that you don’t have to understand much about electricity to understand computers. Here is as complicated as it gets. There are actually a half dozen electronic parts inside of this device that make it work, but we are not going to examine those parts in this book. Someone who has an electronics background could look at what’s in there, and in about 30 seconds would say “Oh yeah, if both inputs are on, the output will be off, and for any other combination the output will be on, just like the book says.” And then that person could go ahead and read this book without ever having to think about what’s in there again. Someone who doesn’t know electronics misses out on those few seconds of understanding, but this book is the same for everyone.  In normal house wiring, one switch turns one light on and off. In the computer, it takes two switches, and it’s sort of backwards in that they both have to be on to turn the light off. But if you accept the fact that something could be made that operates this way, you can then understand how everything in the computer works.  This type of computer part is in fact the ONLY type of part required to build a computer. Of course it takes a lot of them to build a complete computer, but with enough of them, you can make any type of computer. So there you go again, see how simple a computer is? It is just full of this little type of thing – a lot of them to be sure, but this is all there is.  Now we need to give this device a name, this thing inside the computer that bits are made of, it is called a “gate.” I can’t find a good reason why it is called a gate, a gate in a fence lets people through when it is open, and stops people when it is closed. A computer 21 gate generates a third bit from two other bits, it doesn’t open and close or stop or let anything through.  The meaning of this computer term “gate” doesn’t seem to fit into the common meaning of the word, but sorry, I didn’t make up the name, that’s just what it is called.  You’ll get used to it. At least it isn’t some long word from the ancient Greek.  In the next few chapters, we are going to show how we can do something useful by connecting several gates together. We will use drawings like the following. The ‘D’ shape with the little circle at its tip represents the device we have described, and the lines represent the wires going in and coming out of it that get attached to other parts of the computer. The picture on the left shows a gate complete with its power wires, but as promised, we won’t be concerned with them for the rest of this book. The drawing on the right shows everything we need: This is a representation of a gate. The two wires on the left (a and b) are the inputs, and the wire on the right (c) is the output. All three wires are bits, which means that they are either on or off. Each input bit comes from somewhere else in the computer and is either on or off depending on what is happening where it came from, and then this gate sets its output on or off depending on the states of its two inputs.  Sometimes it is useful to make a little chart that shows how the various input combinations create the output, like this: a b c 22 Off Off On Off On On On Off On On On Off Each line shows one possible combination of the inputs, and what the output will be under those circumstances.  Compare this little chart with the experience with the odd room with the two light switches. If one switch is called ‘a,’ the other switch is called ‘b,’ and the ceiling light is called ‘c,’ then this little chart describes completely and exactly how the equipment in that room operates. The only way to get that light off is to have both switch ‘a’ and switch ‘b’ on.  23 Simple Variations As mentioned, this gate is the only thing you need to build a computer, but you need a lot of them, and they have to be wired together in an intelligent manner in order to be able to make them do something useful. What we are going to do here is to show two simple things that are done many times inside any computer.  This first one is very simple. Take the gate above, and take the two input wires, ‘a’ and ‘b,’ and tie them together. Thus ‘a’ and ‘b’ will always be the same. They can still be changed on and off, but ‘a’ and ‘b’ can never be different. ‘A’ and ‘b’ can either both be on, or both be off. Thus the chart of this combination only has two lines on it, two possibilities: a b c Off Off On On On Off Actually, since columns ‘a’ and ‘b’ are the same, there is really only one input and it can be drawn simply like this with a triangle instead of the ‘D’ shape. Its chart is also very simple: 24 a c Off On On Off For our second variation, lets combine one of our original type of gate with the new gate that we just invented, like this: And we’ll combine the charts of how they work. The ‘a,’ ‘b’ and ‘x’ are like the first gate, the ‘x’ and ‘c’ are like the second gate.  a b x c Off Off On Off Off On On Off On Off On Off On On Off On This combination is used so often inside computers, that it is built as a single unit, and the ‘x’ bit is not available to connect to. So to make it simpler to understand, it is drawn as a single unit like this: 25 The only difference between this picture and the picture of our original gate is that the little circle after the big ‘D’ is missing.  Since ‘x’ is not used, the chart can also be simplified, and it looks like this: a b c Off Off Off Off On Off On Off Off On On On The only difference between this chart and the chart of our original gate is that every item in column ‘c’ is the opposite of what it was in the original chart.  Imagine that this combination of gates was installed in that room with the two light switches and the ceiling light. The only way the light could be on is if both switches were on. So if you walked in there and saw the light on, and then looked at the switches, you would see that they were both on. No matter which switch you decided was for the light, and you switched it off, the light would go off. You might not notice that if you turned both off, and then wanted to turn the light back on, you wouldn’t be able to do it by just flipping one switch. You would have to go through the same experiment, flipping both switches until the light came on, and you would find that one switch and the other switch would have to be on to get the light to light.  26 This combination gate could be described this way: For the output to be on, one input AND the other input must both be on. Thus this type of gate has a name, and in the tradition of the informal terminology invented by computer people, because it reminds us of what the word AND means, it is simply called an “AND gate.” Now to fill in a few details purposely left out above, the original gate we looked at works like the AND gate except the output is the opposite, or the negative of the AND gate. Thus it is called a Negative AND gate, or just a “NAND gate” for short.  The simple gate that had both inputs tied together also has its own name. The output is always the opposite of the one input, that is, if the input is on, the output is not on (off.) If the input is off, the output is not off (on.) The output is always NOT what the input is, thus, it is called a “NOT gate.” Notice the difference between the diagrams of the AND gate and the NAND gate. They are the same except that there is a little circle at the beginning of the output of the NAND gate. The thing that looks like a large letter ‘D’ means to do the ‘AND’ function, which means to take action only if both inputs are on, and the little circle means switch to the opposite. So an AND gate is on if both inputs are on, a NAND gate is off if both inputs are on. The NOT gate starts with a triangle, which just means take the input and turn it into an output. The circle then means to switch to the opposite.  The AND gate is used a lot in computers, and it is probably the easiest to understand, but we looked at the NAND gate first for two reasons. The first and less important reason is that the NAND gate is the easiest gate to build. When you have to build a large number of gates, it will be cheaper and more reliable if you can use the type of gate that is easiest to build.  The second, and very important reason that we looked at the NAND gate first is this: That everything in a computer that makes it a computer, can be made out of one or more NAND gates. We have already seen that the NOT gate and the AND gate can be made out of NAND gates, and we will see a few more interesting combinations as we go along. But every one of them is based on this 27 silly little thing called a NAND gate.  The problem in this chapter has been that the NAND gate is the basic building block of computers, but the AND gate is the first gate that has a name that makes sense.  So we looked first at the NAND gate and the NOT gate without giving them names. Then we built an AND gate, gave it its name, and went back and named the first two.  As a note on the language here, the word ‘and’ is a conjunction in regular English. It connects two things, as in “I like peas and carrots.” In computers, we use the word in two new ways. First, it is an adjective, a word that modifies a noun. When we say “this is an AND gate,” the word “gate” is a noun, and the word “AND” tells us what kind of a gate it is. This is how “AND” has been used in this chapter. “AND” will also be used as a verb, as in “let us AND these two bits.” We will see AND used in this way later in the book.  So back to the simplicity theme of this book, we have said that there is only one thing in computers, bits.  And now we see that bits are constructed using gates, and all gates come down to the NAND gate. So all you have to know to understand computers is this very simple device, the NAND gate. No kidding! Can you understand this thing? Then you can understand the whole computer.  28 Diagrams If you want to see how a mechanical machine works, the best way to do it is to look inside of it, watch the parts move as it operates, disassemble it, etc. The second best way is to study it from a book that has a lot of pictures showing the parts and how they interact.  A computer is also a machine, but the only thing that moves inside of it is the invisible and silent electricity. It is very boring to watch the inside of a computer, it doesn’t look like anything is happening at all.  The actual construction of the individual parts of a computer is a very interesting subject, but we are not going to cover it any further than to say the following: The technique starts with a thin crystal wafer, and in a series of steps, it is subjected to various chemicals, photographic processes, heat and vaporized metal. The result is something called a ‘chip,’ which has millions of electronic parts constructed on its surface. The process includes connecting the parts into gates, and connecting the gates into complete computer sections.  The chip is then encased in a piece of plastic that has pins coming out of it. Several of these are plugged into a board, and there you have a computer. The computer we are going to ‘build’ in this book could easily fit on one chip less than a quarter of an inch square.  But the point is, that unlike a mechanical machine, the actual structure of a chip is very cluttered and hard to follow, and you can’t see the electricity anyway. The diagrams we saw in the previous chapter are the best way to show how a computer works, so we’d better get pretty good at reading them.  Throughout the rest of this book, we are going to build new parts by connecting several gates together. We will describe what the new part does, and then give it a name and its own symbol. Then we may connect several of those new parts into something else that also gets a name and a symbol. Before you know it, we will have assembled a complete computer.  Every time there is a new diagram, the text will explain 29 what its purpose is, and how the parts achieve it, but the reader really must look the diagram over until it can be seen that the gates actually do what the book says they will do. If this is done faithfully with each one, you will very shortly see exactly how a computer works.  There are only two things in our drawings, there are parts that have inputs and outputs, and there are lines, or wires, that connect outputs and inputs together.  When electricity comes out of the output of a gate, the electricity travels through the whole wire as fast as it can go. If the output of a gate is on, then the electricity is on in the wire that is connected to it, for as far as it goes. If the output of a gate is off, the whole wire is off. I guess you could consider that the bit that comes out of the gate includes the whole wire as well.  The inputs of gates do not use up the electricity in the wire, so one output may be connected to the input of one or many gates.  When wires are connected together, this is shown by a dot where they meet on the diagram, and all wires that are connected together get electricity as if they were one wire. When wires cross on a diagram without a dot, it means that there is no connection between them, they are not touching, the two bits are separate.  Whenever there is a choice, the diagrams will show the path of the electricity moving from left to right, or from the top of the page towards the bottom. However, there will be many exceptions to this, especially later on in the book. But you can always tell which way the electricity is moving in a wire by starting at an output and following it to an input.  Most of the diagrams in the book are very easy to follow. In a few cases, there will also be one of those charts that shows what the output will be for every possible combination of inputs. If you have trouble following a diagram, you can pencil in the ons and offs right on the page, or place coins on the page and flip them so that heads means on and tails means off.  Unfortunately, the diagram in the next chapter is 30 probably the hardest one to follow in the whole book, but once you master it, you’ll be an expert diagram reader.  31 Remember When You have probably heard of computer memory, and now we are going to see exactly what that is. Since the only thing inside of computers is bits, and the only thing that happens to bits is that they either turn on or turn off, then it follows that the only thing a computer can ‘remember’ is whether a bit was on or off. We will now see how that is accomplished.  The following diagram shows one bit of computer memory.  It happens to be one of the neatest tricks you can do with a few gates. We will examine how it works here at great length, and after we understand it, we will replace it with its own symbol, and use it as a building block for bigger and better things.  It is made of only four NAND gates, but its wiring is kind of special. Here it is: This combination as a whole has two inputs and one output. ‘I’ is where we input the bit that we want to remember, and ‘o’ is the output of the remembered bit.  ‘S’ is an input that tells these gates when to ‘set’ the memory. There are also three internal wires labeled ‘a’, ‘b’ and ‘c’ that we will have to look at to see how these parts work together. Try to follow this carefully, once you see that it works, you will understand one of the most important and most commonly used things in a computer.  To see how this works, start with ‘s’ on and ‘i’ off.  Since ‘i’ and ‘s’ go into gate 1, one input is off, so ‘a’ will be on. Since ‘a’ and ‘s’ go to gate 2, both 32 inputs are on, and therefore ‘b’ will be off. Looking at gate 4, since ‘b’ is off, the output of gate 4, ‘c’ will be on. Since ‘c’ and ‘a’ are both on, the output of gate 3, ‘o’ will be off. ‘O’ goes back down to gate 4 providing a second off input, leaving ‘c’ still on. The important thing to note here is that with ‘s’ on, ‘o’ ends up the same as ‘i.’ Now with ‘s’ still on, lets change ‘i’ to on. Since ‘i’ and ‘s’ go into gate 1, ‘a’ will be off. ‘A’ goes to one side of both gate 2 and gate 3, therefore their outputs ‘o’ and ‘b’ must both be on. ‘O’ and ‘b’ both on go into gate 4 and turn ‘c’ off, which goes back up to gate 3 providing it with a second off input, leaving ‘o’ still on. The important thing to note here is the same thing we noted in the previous paragraph - that with ‘s’ on, ‘o’ ends up the same as ‘i.’ So far, we have seen that when ‘s’ is on, you can change ‘i’ on and off, and ‘o’ will change with it. ‘O’ will go on and off just the same as ‘i.’ With ‘s’ on, this combination is no more useful than a wire connecting ‘i’ to ‘o.’ Now let’s see what happens when we turn ‘s’ off. Look at gate 1. When ‘s’ is off, ‘a’ will be on no matter what you do to ‘i.’ Now you can switch ‘i’ on and off and nothing will happen. The same goes for gate 2. ‘A’ may be on, but ‘s’ is off, so ‘b’ can only be on. Both ‘a’ and ‘b’ are on, and changing ‘i’ does nothing. Now the only thing left that matters, the big question is, what will ‘o’ be?  If ‘i’ and ‘o’ were on before ‘s’ got turned off, gate 3 had both inputs off, and gate 4 had both inputs on. When ‘s’ goes off, ‘a’ comes on, which is one input to gate 3. But the other input is off, so nothing changes, ‘o’ stays on.  If ‘i’ and ‘o’ were off before ‘s’ got turned off, gate 3 had both inputs on, and gate 4 had both inputs off.  When ‘s’ goes off, ‘b’ comes on, which is one input to gate 4. But the other input is off, so nothing changes, ‘c’ stays on and ‘o’ stays off.  So the answer to the question of what happens to ‘o’ when ‘s’ is turned off, is that it stays the way it was, and it is no longer affected by ‘i.’ 33 Now what do we have here? With ‘s’ on, ‘o’ does whatever ‘i’ does. With ‘s’ off, ‘o’ stays the way it and ‘i’ were, at the last instant just before ‘s’ went off. Now ‘i’ can change, but ‘o’ stays the way it was. This combination of gates locks in the way ‘i’ was at an earlier time. This is how a combination of four NAND gates can “remember.” This is only one bit of memory, but this is the basic building block of all computer memory. All that computer memory is, is a way of preserving the way a bit was set at some point in time.  I hope you followed the wires and the ons and offs in this chapter. Once you see exactly how this thing works, you will know that these simple NAND gates can create a memory bit, and I assure you that you will never wonder about it again.  Now that we know how this thing works, we no longer need to look at that tricky internal wiring of this combination. We have seen how it works, and from now on, we will just use this diagram to represent it: ‘I’ is the input bit that you want to save. ‘S’ is the input that allows ‘i’ into the memory bit when ‘s’ is on, and locks it in place or ‘sets’ it when ‘s’ goes off. ‘O’ is the output of the current or saved data. ‘M’ stands for Memory. Pretty simple, eh?  Let’s go back to our room with the funny light switches.  It had a NAND gate hooked up in it. Let’s take the NAND gate out and replace it with this new memory bit. We’ll connect the left switch to the ‘i’ wire, the right switch to the ‘s’ wire, and the ceiling light to the ‘o’ wire. We could start out with everything looking the same, that is, the light is on, but both switches are off. That would mean that at some point in the past, both ‘i’ and ‘s’ were on, and ‘s’ got turned off first, locking the then state of ‘i’ into our memory bit, which then comes out at ‘o.’ Then ‘i’ could have been switched off without affecting anything. So if we walked in and decided that we wanted to turn the light off, we would first try the ‘i’ switch, turn it on and off, and 34 nothing would happen. Then we would try the ‘s’ switch.  When we turn it on, the light would go off. Aha we say, the ‘s’ switch controls the light, but it is installed up-side-down! So then we turn the ‘s’ switch back off, expecting the light to come back on, but the light remains off. Now the switches are in the same position as they were when we entered the room, they’re both off, but now the light is off as well, boy is this confusing.  Now I don’t want to speculate on how much cursing would go on before someone figured this out, but in the end they would find that when ‘s’ was on, the light went on and off with ‘i,’ and when ‘s’ was off, the light would stay the way it was just before ‘s’ got turned off.  35 What Can We Do With A Bit?  Now we have described a bit, we have shown how to build one, how to remember over time what state a bit was in at an earlier instant in time, now what? What do we do with it?  Since a bit is actually nothing more than the electricity being on or off, the only actual, real thing we can do with a bit is to turn lights on or off, or toasters or whatever.  But we can also use a bit to represent something else in our lives. We can take a bit, and connect it to a red light, and say that when this bit is on, it means stop, and when this bit is off, you may go. Or if a particular bit is on, you want fries with your burger; if it is off, you want the burger only.  This is the action of using a code. What is a code? A code is something that tells you what something else means. When something is supposed to mean something, somewhere someone has to make a list of all of the states of the ‘thing,’ and the meanings associated with each of those states. When it comes to a bit, since it only can be in two different states, then a bit can only mean one of two things. A code for a bit would only need two meanings, and one of those meanings would be associated with the bit being off, and the other meaning would be associated with the bit being on.  This is how you assign meaning to a bit. The bit does not contain any meaning in and of itself; there is no room in a bit for anything other than the presence or absence of electricity. Meaning is assigned to a bit by something external to the bit. There is nothing about traffic or French fries in a bit, we are just saying that for this bit in this place, connected to a red light hanging over an intersection, when it is on, you must stop, when it is off, you may go. Another bit, in a cash register in a fast food restaurant, means put fries in the bag when the bit is on, or no fries when it is off.  These are two cases of someone inventing a simple twoitem code. In one case, the code is: bit on means fries, 36 bit off means no fries, in the other case, bit off means go, bit on means stop. These two bits are the same, they are just used for different purposes, and someone decides what the meaning of these two bits will be. The code is written down somewhere in the law books, or in the restaurant manager’s handbook, but the code is not in the bit. The state of the bit merely tells someone which line of the code they are supposed to believe is true at the current moment. That’s what a code is.  Like the spies who pass messages by using a secret code, the message may be seen by other people, but those other people don’t have the code, so they don’t know what the message means. Maybe one spy has a flowerpot sitting on the sill in the front window of his apartment. When the pot is on the left side of the sill, it means “Meet me at the train station at 1:30.” And when the flowerpot is on the right side of the sill, it means “No meeting today.” Every day, the other spy walks down the street and glances up at that window to see whether he needs to go to the train station today. Everyone else who walks down that street can just as easily see this message, but they don’t have the code, so it means nothing to them. Then when the two spies do meet, they can pass a piece of paper that is written in another secret code.  They encode and decode the message using a codebook that they do not carry when they meet. So if their message is intercepted by anyone else, it won’t mean anything to that someone else. Someone who doesn’t have the codebook won’t have the proper meanings for the symbols on the sheet of paper.  A computer bit is still, and will always be, nothing more than a place where there is or is not electricity, but when we, as a society of human beings, use a bit for a certain purpose, we give meaning to the bit. When we connect a bit to a red light and hang it over an intersection, and make people study driver’s handbooks before giving them driver’s licenses, we have given meaning to that bit. Red means ‘stop,’ not because the bit is capable of doing anything to a vehicle traveling on the road, but because we as people agree that red means stop, and we, seeing that bit on, will stop our car in order to avoid being hit by a car traveling on the cross street, and we hope that everyone else will do 37 the same so that we may be assured that no one will hit us when it is our turn to cross the intersection.  So there are many things that can be done with a bit. It can indicate true or false, go or stop. A single yes or no can be a major thing, as in the answer to “Will you marry me?” or an everyday matter such as “Would you like fries with that?” But still, there are many things that cannot be done with a bit, or seem to be incompatible with the idea of bits altogether. There can be many examples of yes/no things in everyday life, but there are many more things that are not a simple yes or no.  In the case of the telegraph, which was indisputably just one bit, how can there be more than two items in the Morse code? The answer is that the ability to send and receive messages depended on the skills and the memories of the operators at both ends of the wire. In the Morse Code, if the key was pressed for a very short time, that was called a “dot(.),” and if it was pressed for a slightly longer time, that was called a “dash(-).” Each letter of the alphabet was assigned a unique combination of dots and or dashes, and both operators studied the code, memorized it and practiced using it.  For instance, the code for the letter ‘N’ was dash dot (-.) and the code for the letter ‘C’ was dash dot dash dot (-.-.). The length of the on times were different to make dots and dashes, and the lengths of the off times were different to distinguish between the time that separates dots and dashes within a letter, the time that separates letters, and the time that separates words.  You need a longer off time to keep from confusing a ‘C’ with two ‘N’s. The receiving person had to recognize these as patterns – that is, he had to hear and remember the lengths of several on and off times until he recognized a letter. The telegraph apparatus didn’t have any memory at all, there was never even one whole letter on the wire at any one time, the pieces of letters went down the wire, to be assembled into dots and dashes in the mind of the operator, then into letters, and then into words and sentences written on a sheet of paper. So the telegraph bit achieves more than two meanings by having several individual times when there may be ons or offs.  38 If a computer were built on the principles of the Morse code, it would just have a light bulb on top of it flashing the code at us. Since we’d rather see whole letters, words and sentences on the screen simultaneously, we need something more than a single bit and this old code.  Even in the examples used in this chapter, real traffic lights actually have three bits, one for red, one for yellow and one for green. If you had only one bit, you could just have a red light at the intersection, and when it was on that would mean stop, and when it was off that would mean go. But when it was off, you might wonder whether it was really off, or whether the bulb had just burned out. So using three bits is a lot more useful in this case.  In the real world, we have already seen that computers can contain letters, words, sentences, entire books, as well as numbers, pictures, sounds and more. And yet, all of this does come down to nothing more than bits.  If we want our computer memory to be able to hold more than an on or off, or yes or no, we will have to have something more than just one bit. Fortunately, we can do something much more useful just by using several bits together, and then making up a code (or maybe several codes) to assign some useful meaning to them.  39 A Rose by Any Other Name Before we go on, we are going to introduce a change to what we call something. As we know, all of the bits in the computer are places where there is or is not, some electricity. We call these states, “on” and “off,” and that is exactly what they are. Even though these are short words, there are places where it is a lot easier, clearer and simpler to use a single symbol to describe these states. Fortunately, we’re not going to invent anything tricky, we’re just going to use two symbols you already know well, the numbers zero and one. From here on out, we will call off 0, and we will call on 1. And sometimes we will still use on and off.  Thus the chart for our NAND gate will look like this: a b c 0 0 1 0 1 1 1 0 1 1 1 0 This is very easy to understand, of course, but the point that needs to be made here, is that the computer parts have not changed, the only thing that has changed is what we, as people looking at the machine, are calling it. Just because we call a bit a zero or one, that doesn’t mean that suddenly numbers have appeared and are running around inside the computer. There are still no numbers (or words or sounds or pictures) in a computer, only bits, exactly as previously described. We 40 could have called them plus and minus, yes and no, true and false, heads and tails, something and nothing, north and south, or even Bert and Ernie. But zero and one will do it. This is a just a simple, two item code. On means 1, and off means 0.  As a comment here, there seems to be a trend among the appliance manufacturers of the world to replace the obsolete and old-fashioned terms of on and off with the modern 0 and 1. On many power switches they put a 0 by the off position, and a 1 by the on position. The first place I saw this was on a personal computer, and I thought that it was a cute novelty, being on a computer, but now this practice has spread to cell phones, coffee makers and automobile dashboards. But I think that this is a mistake. Do you understand that the code could just as easily have been defined as “off means 1 and on means 0?” The computer would work exactly the same way, only the printing in the technical manuals that describe what is happening inside the computer would change.  When you see one of these 0/1 switches, you have to translate it back from this very commonly used computer code into what it really means, on or off. So why bother? You don’t want to turn your coffee machine ‘1’, you want the power ON so you can get your java and wake up already. Imagine putting these symbols on a waffle maker back in 1935. Nobody would have had any idea of what it meant. It is probably just so that manufacturers don’t have to have switches printed in different languages. Or maybe this trend comes from an altruistic desire to educate the public into the modern ‘fact’ that a 1 is the same as on, but it isn’t a fact, it’s an arbitrary code.  41 Eight Is Enough In order to be able to represent something more than simple yes/no matters, what we are going to do is to stack up eight bits in a single package, and use them as a single unit. Here is a diagram of how it is done. We have taken eight of our memory bits, each one still has its own data input ‘i’ and its own output ‘o,’ but we have wired all eight of the set inputs ‘s’ together.  Thus when the single ‘s’ gets turned on and then off again, all eight of these ‘M’s will capture the states of their corresponding ‘i’s at the same time. The picture on the left shows all eight ‘M’s, the one on the right is the same thing, just a little simpler.  42 This assembly has a name; it is called a byte, thus the “B” in the diagram. There are several conflicting explanations of exactly where this word came from, but since it sounds just like the word “bite,” you can just think of it as a whole mouthful compared with a smaller unit, a bit. Just to show you that computer designers do have a sense of humor, when they use four bits as a unit, they call it a nibble. So you can eat a tiny bit of cherry pie, or have a nibble or take a whole byte.  When we had a bit, we would just say that its state was either 0 or 1. Now that we have a byte, we will write the contents of the byte like this: 0000 0000, and you can see why we switched from using off/on to 0/1. That 43 shows the contents of each of the eight bits, in this case they are all zeros. The space in the middle is just there to make it a little easier to read. The left hand 0 or 1 would correspond to the top bit in our byte, and the rightmost 0 or 1 would represent the bottom bit.  As you had better know by now, a bit has two possible states that it can be in — on or off. If you have two bits, there are four possible states that those two bits can be in. Do you remember the chart we drew for the inputs of the NAND gate? There were four lines on the chart, one for each possible combination of the two input bits to the gate, 0-0, 0-1, 1-0 and 1-1.  Notice that the order of the bits does matter – that is, if you look at two bits and only ask how many bits are on, there are only three possibilities: no bits on, one bit on or two bits on. That would be calling the 1-0 and 0-1 combinations the same thing. For the purpose of using multiple bits to implement a code, we definitely care about the order of the bits in a byte. When there are two bits, we want to use all four possibilities, so we have to keep the bits in order.  How many different possibilities are there when you use eight bits? If all you have is one bit, it can be in one of two states. If you add a second bit, the pair has twice as many states as before because the old bit has its two states while the new bit is one way, and then the old bit has its two states while the new bit is the other way. So two bits have four states. When you add a third bit, the first two have four states with the new bit off and four states with the new bit on, for a total of eight states. Every time you add a bit, you just double the number of possible states. Four bits have 16 states, five have 32, six have 64, seven have 128, eight have 256, nine have 512 states, and so on.  We are going to take eight bits, and call it a byte.  Since a bit is a thing that has a location in space, that can be in one of two states, then a byte is a thing that has eight separate locations in space, each of which can be on or off, that are kept in the same order.  The byte, taken as a whole, is a location in space that can be in any one of 256 states at any given time, and may be made to change its state over time.  44 Codes A bit could only represent yes/no types of things, but now that we have 256 possibilities, we can look for things in our lives that are slightly more complicated.  One of the first things that might fit the bill is written language. If you look in a book and see all of the different types of symbols that are used to print the book, you will see all 26 letters of the alphabet in uppercase as well as lowercase. Then there are the numbers 0 through 9, and there are punctuation marks like periods, commas, quotes, question marks, parentheses and several others. Then there are special symbols like the ‘at’ sign (@,) currency ($,) and more.  If you add these up, 52 letters, 10 numbers, a few dozen for punctuation and symbols, you get something like 100 different symbols that may appear printed on the pages of the average book.  From here on out, we will use the word ‘character’ to mean one of this sort of thing, one of the letters, numbers, or other symbols that are used in written language. A character can be either a letter, a number, a punctuation mark or any other type of symbol.  So we have written language with about 100 different characters, and our byte with 256 possibilities, maybe we can represent language with bytes. Lets see, how do you put an ‘A’ into a byte? There is nothing inherent in a byte that would associate it with a character, and there is nothing inherent in a character that has anything to do with bits or bytes. The byte doesn’t hold shapes or pictures. Dividing a character into eight parts does not find any bits.  The answer, as before, is to use a code to associate one of the possible states of the byte with something that exists in the real world. The letter ‘A’ will be represented by a particular pattern of 1s and 0s in the bits of a byte. The byte has 256 different possible states, so someone needs to sit down with pencil and paper and list out all 256 of those combinations, and next to each one, put one of the characters that he wants that pattern to represent. Of course, by the time 45 he gets to the 101 st line or so, he’ll run out of characters, so he can add every type of rarely used symbol he can think of, or he can just say that the rest of the combinations will have no meaning as far as written language is concerned.  And so, in the early days of computers, each manufacturer sat down and invented a code to represent written language. At some point, the different companies realized that it would be beneficial if they all used the same code, in case they ever wanted their company’s computers to be able to communicate with another brand.  So they formed committees, held meetings and did whatever else they needed to do to come up with a code that they could all agree on.  There are several versions of this code designed for different purposes, and they still hold meetings today to work out agreements on various esoteric details of things. But we don’t need to concern ourselves with all that to see how a computer works. The basic code they came up with is still in use today, and I don’t know of any reason why it would ever need to be changed.  The code has a name, it is the: American Standard Code for Information Interchange. This is usually abbreviated to ASCII, pronounced “aass-key.” We don’t need to print the whole code here, but here’s a sample. These are 20 of the codes that they came up with, the first 10 letters of the alphabet in uppercase and lowercase: PART OF ASCII CODE TABLE A 0100 0001 a 0110 0001 B 0100 0010 b 0110 0010 C 0100 0011 c 0110 0011 D 0100 0100 d 0110 0100 E 0100 0101 e 0110 0101 F 0100 0110 f 0110 0110 G 0100 0111 g 0110 0111 H 0100 1000 h 0110 1000 46 I 0100 1001 I 0110 1001 J 0100 1010 j 0110 1010 Each code is unique. It’s interesting to note the way that they arranged the codes so that the codes for uppercase and lowercase of the same letter use the same code except for one bit. The third bit from the left is off for all uppercase letters, and on for all lowercase letters.  If you wanted to put a message on your computer screen that said “Hello Joe” you would need nine bytes. The first byte would have the code for uppercase “H”, the second byte would have the code for lowercase “e”, the third and fourth bytes would have the code for lowercase “l”, the fifth byte would have the code for lowercase “o”, the sixth byte would have the code for a blank space, and bytes seven, eight and nine would contain the codes for “J”, “o” and “e.” Notice that there is even a code for a blank space (it is 0010 0000 by the way.) You may wonder why there needs to be a code for a blank space, but that just goes to show you how dumb computers are. They don’t really contain sentences or words, there are just a number of bytes set with the codes from the ASCII code table that represent the individual symbols that we use in written language. And one of those “symbols,” is the lack of any symbol, called a space, that we use to separate words.  That space tells us, the reader, that this is the end of one word and the beginning of another. The computer only has bytes, each of which can be in one of its 256 states. Which state a byte is currently in, means nothing to the computer.  So let us take a memory byte, and set the bits to 0100 0101. That means that we have put the letter E into the byte, right? Well… not really. We have set the pattern that appears next to the letter E in the ASCII code table, but there is nothing inherent in the byte that has to do with an ‘E.’ If Thomas Edison had been testing eight of his new experimental light bulbs, and had them sitting in a row on a shelf, and the first, third, fourth, fifth and seventh light bulbs had burned out, the remaining light bulbs would be a byte with this 47 pattern. But there wasn’t a single person on the face of the Earth who would have looked at that row of bulbs and thought of the letter ‘E,’ because ASCII had not yet been invented. The letter is represented by the code.  The only thing in the byte is the code.  There you have the subject of codes. A computer code is something that allows you to associate each of the 256 possible patterns in a byte with something else.  Another language note here, sometimes the word code refers to the whole list of patterns and what they represent, as in “This message was written with a secret code.” Sometimes code just refers to one of the patterns, as in “What code is in that byte?” It will be pretty obvious from the context which way it is being used.  48 Back to the Byte Do you remember the memory byte we drew a few chapters ago? It was eight memory bits with their ‘s’ wires all connected together. Almost every time that we need to remember a byte inside a computer, we also need an additional part that gets connected to the byte’s output. This extra part consists of eight AND gates.  These eight AND gates, together, are called an “Enabler.” The drawing on the left shows all of the parts, the drawing on the right is a simpler way to draw it.  49 The second input of all eight AND gates are connected together and given the name ‘enable,’ or ‘e’ for short.  When ‘e’ is off, whatever comes into the Enabler goes no further, because the other side of each AND gate is off, thus the outputs of those gates are all going to be off.  When ‘e’ is on, the inputs go through the Enabler unchanged to the outputs, ‘o.’ By the way, when gates are used for something like this, the name “gate” starts to make some sense. An Enabler allows a byte through when the bit ‘e’ is 1 and stops the byte when it is 0. So ‘e’ being on is like opening a gate, and ‘e’ being off is like closing a gate.  50 We will take our byte, and connect it to an enabler, as shown in the left hand drawing. To simplify once again, we can draw it as shown on the right.  Now we have a combination that can store eight bits. It captures them all at the same time, and it can either keep them to itself, or let them out for use somewhere else. This combination of a Byte and an Enabler, has a name, it is called a Register, thus the ‘R’ in the drawing.  There will be a few places in this book where there are registers that never need to have their outputs turned off. In those cases, we will draw a register that only has a ‘set’ bit, and no ‘enable’ bit. We should probably refer to these devices as ‘bytes,’ but we will call them registers nonetheless.  Register simply means a place to record some kind of information, like a hotel register where all the guests sign in, or a check register where you write down each check that is written. In the case of this computer part, you record the state of the eight input bits. This register is very limited though, in that it can only hold one set of values; in a hotel register there is a new line for each guest. Every time you store a new state in a computer register, the previous state of the eight memory bits is lost. The only thing that is in there is the most recently saved value.  51 The Magic Bus There are many places in a computer where eight wires are needed to connect registers together. Our register, for example, has eight memory bits, each of which have an input and an output. To simplify our diagrams, we will replace our eight wires with a double line.  So our register can look like one of these: Or, we can simplify, and replace it with one of these: It’s exactly the same thing, we will just save a lot of ink in our drawings, and they will be easier to understand.  When there is a connection between two of these bundles of wires, one wire of each bundle is connected to one wire of the other bundle as shown in the diagram on the left. But we will simplify it, and just draw it like the diagram on the right.  52 Now, this grouping of eight wires is so common inside computers that it has a name. It is called a bus. Why is it called a bus? Well, it probably has to do with the old electrical term ‘buss,’ that means a bar of metal used as a very large wire in places like power generating plants. But there is also an interesting similarity to the kind of bus that people use for transportation.  A bus is a vehicle that commonly travels along a predetermined route, and makes many stops where people get on or off. They start somewhere, and the bus takes them to some other place they need to be. In the world of computers, a bus is simply a set of eight wires that goes to various places inside the computer. Of course, eight is the number of wires needed to carry a byte of information. Inside the computer, the contents of bytes need to get from where they are to other places, so the bus goes to all these places, and the design of the register allows the contents of any selected byte to get onto the bus, and get off at a selected destination.  In the following example, we have a bus, and there are five registers, each of which has both its input and output connected to the same bus.  If all of the ‘s’ bits and ‘e’ bits are off, each register will be set the way it is, and will stay that way. If you want to copy the information from R1 into R4, first you turn the ‘e’ bit of R1 on. The data in R1 will now be on the bus, and available at the inputs of all five registers. If you then briefly turn the ‘s’ bit 53 of R4 on and back off, the data on the bus will be captured into R4. The byte has been copied. So a computer bus is a little like the bus that carries people. There are a number of stops, and bytes can get to where they need to go.  Notice that we can copy any byte into any other byte.  You can copy R2 into R5, or R4 into R1. The bus works in either direction. The electricity put on the bus when you enable any register goes as fast as possible to the inputs of everything else on the bus. You could even enable one register onto the bus and set it into two or more other registers at the same time. The one thing you don’t want to do is to enable the outputs of two registers onto the bus at the same time.  In terms of the sizes of bits, you could look at it this way: When the ‘e’ bit of R1 gets turned on, the bits in R1 now get longer, they are a bigger space because they are now connected to the bus, so those 8 bits now include R1 and the entire bus. When the ‘s’ bit of R4 gets turned on, the R1 bits get even bigger because they now include R1, the bus and R4. If anything in R1 were to somehow change at this time, the bus and R4 would immediately change with it. When the ‘s’ bit of R4 gets turned off, R4 regains its status as a separate byte, and when the ‘e’ bit of R1 turns off, the bus ceases being a part of R1.  So this is a bus. It is a bundle of eight wires that typically goes to many places.  One more thing about registers: There are many places where we are going to connect the input and output of a register to the same bus, so to simplify even further, we can just show one bundle of wires labeled ‘i/o,’ meaning input and output. All of the following are exactly equivalent as far as how they work. The placement of the wires on the drawing may be adjusted to make it as uncluttered as possible.  54 Another language note: A byte is a location that can be in one of 256 states. Sometimes we talk about moving a byte from here to there. By definition, bytes do not move around inside the computer. The byte only refers to the location, but sometimes when someone wants to refer to the current setting of the byte, and they ought to say “lets copy the contents of R1 into R4,” they simplify and say “move R1 to R4” or “move this byte over there.” They’re using the word byte to refer to the contents of the byte. Again, the context usually makes this very clear. In the example above of copying the contents of R1 into R4, you may hear it described as “moving a byte from R1 to R4.” Technically, R1 and R4 are the bytes, which do not move, only the contents goes from place to place.  Also, the contents do not leave the place where they came from. When you are done “moving” a byte, the “from” byte has not changed, it doesn’t lose what it had. At the other end, the pattern that was originally in the “to” byte is now “gone,” it didn’t go anywhere, it was just written over by the new information. The old pattern simply ceases to exist. The new information is exactly the same as what is still in the first byte. The byte didn’t move, there are still two bytes in two locations, but the information in the first byte has been copied into the second byte.  55 More Gate Combinations Now we are going to show just two more combinations, and then we will be able put together what we know so far, to make the first half of a computer. So don’t get discouraged, just a little further and we’ll be half way home.  The first combination is very simple. It is just an AND gate with more than two inputs. If you connect two AND gates like this diagram on the left, you see that for ‘d’ to be on, all three inputs, ‘a,’ ‘b’ and ‘c’ have to be on. So this combination can simply be drawn like this diagram on the right: And the chart that shows how it operates looks like this: a b c d 0 0 0 0 0 0 1 0 0 1 0 0 0 1 1 0 1 0 0 0 1 0 1 0 56 1 1 0 0 1 1 1 1 Imagine replacing input ‘c’ with another AND gate, then you would have a four input AND gate. You could then replace any of the four inputs with another AND gate, and have a five input AND gate. This can be done as many times as necessary for what you are doing.  As you add inputs, the chart will need more and more lines. Every time you add another input, you double the number of combinations that the inputs can have. The chart we saw for the original two input AND gate had four lines, one for each possibility. The three input, directly above, has eight lines. A four input AND gate will have 16 lines, a five input will have 32, etc. In all cases though, for an AND gate, only one combination will result in the output turning on, that being the line where all inputs are on.  Here is the last combination we need to make the first half of a computer. This combination is different from anything we have looked at so far, in that it has more outputs than inputs. Our first example has two inputs and four outputs. It is not very complicated, it just has two NOT gates and four AND gates.  In the diagram below, ‘a’ and ‘b’ are the inputs coming in from the left. Both of them are connected to NOT gates. The NOT gates generate the opposite of their inputs. There are four vertical wires going down the page that come from ‘a’ and ‘b’ and the opposites of ‘a’ and ‘b.’ Thus, for each ‘a’ and ‘b,’ there are two wires going down the page, where one of them will be on if its input is on, and the other will be on if its input is off. Now we put four AND gates on the right, and connect each one to a different pair of the vertical wires such that each AND gate will turn on for a different one of the four possible combinations of ‘a’ and ‘b.’ The top 57 AND gate, labeled “0/0” is connected to the wire that is on when ‘a’ is off, and the wire that is on when ‘b’ is off, and thus turns on when ‘a’ and ‘b’ are both 0. The next AND gate, “0/1” is connected to the wire that is on when ‘a’ is off, and ‘b,’ so it turns on when ‘a’ is 0 and ‘b’ is 1, etc.  The inputs can be on in any combination, both bits off, one on, the other on, or both on. None, one or two on.  The outputs, however, will always have one and only one output on and the other three off. The one which is on is determined by the current states of ‘a’ and ‘b.’ a b 0/0 0/1 1/0 1/1 58 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 0 1 0 1 1 0 0 0 1 This combination is called a decoder. The name means that if you consider the four possible states of the two inputs as a code, then the output tells you which of the codes is currently on the input. Maybe it’s not a great name, but that’s what it meant to someone once, and the name stuck. This decoder has two inputs, which means that there can be four combinations of the states of the inputs, and there are four outputs, one corresponding to each of the possible input combinations.  This can be extended. If we added a third input, there would then be eight possible input combinations, and if we used eight, three input AND gates, we could build a three input, eight output decoder. Similarly, we could build a four input, 16 output decoder. Decoders are named by the number of inputs “X” the number of outputs.  Like 2X4, 3X8, 4X16, 5X32, 6X64, etc.  59 Again, we will simplify our drawings, we won’t show any of the internal parts or wiring, we’ll just have a box with a name and the inputs and outputs that we are interested in. We have seen how NAND gates make NOT gates and AND gates, and then NOT gates and AND gates make a Decoder. It is a box full of NAND gates wired up to do something useful. We know what it does, one and 60 only one of the outputs is always on, and which one it is, is determined by the state of the three inputs.  That’s all it does.  61 First Half of the Computer Lets build something with the parts we have so far.  Actually, we can now build fully half of what’s in a computer.  First, let’s build something similar out of wood (in our minds,) then we’ll come back and show how to build a computer version that does pretty much the same thing.  You know in a hotel, at the front desk, on the wall behind the clerk, there are a series of little wooden cubbyholes, one for each room in the hotel. That’s where they keep extra room keys and messages or mail for the guests. Or you may have seen an old movie where someone in an old post office was sorting the mail. He sits at a table with a series of cubbyholes at the back. He has a pile of unsorted mail on the table, picks up one at a time, reads the address, and puts the letter in the appropriate cubbyhole.  So we’re going to build some cubbyholes. Ours will be three inches square, and there will be sixteen cubbyholes high and sixteen cubbyholes across. That’s a total size of four feet by four feet, with a total of two hundred fifty six cubbies.  Now we’ll add something that they don’t have in the post office or the hotel. We’re going to put a large wood panel right in front of the cubbies which is twice as wide as the whole thing, and in the middle it has a vertical slot that is just large enough to expose one column of 16 cubbies. The panel will have wheels on the bottom so it can slide left and right to expose any one of the vertical columns of sixteen cubbies at a time, and cover all of the other columns.  Let’s take another wood panel just like the first, but turn it up sideways so it is twice as high as our cubbyholes, and the slot in the middle goes side to side. This second panel will be mounted right in front of the first, in something like a window frame, so it can slide up and down, exposing just one row of sixteen cubbies at a time.  So now we have a series of 256 cubbyholes, and two slotted wooden panels in front of them that allow only 62 one cubby at a time to be visible. In each of these cubbies, we will place a single slip of paper on which we will write one of the possible combinations of eight zeros and ones.  This cubbyhole device has 256 places to store something.  At any given time, we can select one and only one of those places by sliding the wood panels side to side or up and down. At the selected cubbyhole, we can reach in and get the slip of paper and read it, or replace it with another one.  Now we will take the gates, registers and decoders that we have described, and make something out of them that does pretty much the same thing as our cubbyhole device.  This thing will have 256 places in which to store something, and we will be able to select one and only one of those places at any given time.  Referencing the diagram below, we start with a single register. Its input ‘a,’ is a bus that comes from somewhere else in the computer. A combination of bits is placed on the bus and the ‘sa’ (set a) bit goes 1 then 0. That bit pattern is now stored in this register, which is one of those registers whose output is always on. The first four output bits are connected to one 4X16 decoder, and the other four output bits are connected to another 4X16 decoder. The outputs of the two decoders are laid out in a grid pattern. The wires do not touch each other, but there are 16 by 16, or 256 intersections here that we will make use of soon. A decoder, as stated, has one and only one of its outputs on at any time, and the rest are off. Since we have two decoders here, there will be one horizontal grid wire on, and one vertical grid wire on. Therefore, of these 256 intersections, there will be only one intersection where both the horizontal and vertical wires are on. Which intersection that is will change every time the value in R is changed, but there will always be one where both wires are on while the other 255 will have only one on or none on.  63 At the bottom of this diagram is one bus and an ‘s’ and ‘e’ bit, just the same as the connections that go to a register. As you can see, they go upwards and into the grid. The diagram doesn’t show it, but they go up under 64 the grid all the way to the top, so that each of the 256 intersections has a bus and an ‘s’ and ‘e’ bit nearby.  There is a circle on the diagram above, around one of the intersections of the grid. What is in this circle is magnified in the diagram below, showing that there are three AND gates and one register at each of the 256 intersections. As we can see, there is an AND gate ‘x,’ connected to the one vertical grid wire and the one horizontal grid wire at this intersection. These ‘x’ gates are the only things connected to the grid. The rest of the connections go down to the bus and ‘s’ and ‘e’ bits at the bottom of the diagram. Remember that there is only one intersection where both grid wires are on. Therefore, there are 256 of these ‘x’ gates, but only one of them has its output on at any given time.  The output of that ‘x’ gate goes to one side each of two more AND gates. These two gates control access to the set and enable inputs of the register at that intersection. So when an ‘x’ gate is off, the ‘s’ and ‘e’ bits of that register cannot be turned on. That will be the case for 255 of these registers, the ones where the ‘x’ gate is off. But one intersection has its ‘x’ gate on, and its register can be set from the bus, or its contents can be enabled onto the bus and sent elsewhere by using the ‘s’ and ‘e’ bits at the bottom of the diagram.  65 The above is the computer’s main memory. It is half of what is necessary to build a computer. It is sometimes called by different names, but the most correct name comes from the fact that you can select any one of the 256 bytes one moment, and then you can immediately select any other of the 256 bytes, and it does not matter where the last one was, or where the next one is, there is no speed advantage or disadvantage to the order in which you select the bytes. Because of this quality, this is a good type of memory to use if you want to be able to access the bytes of memory in a random order. So this type of memory is called “Random Access Memory,” or “RAM” for short.  This is RAM. It uses 257 registers. 256 registers are memory storage locations, one register is used to select one of the storage locations and is called the “Memory Address Register” or “MAR” for short. Now that we know what’s in it, we can make a simplified diagram like this, and an even simpler bus version: 66 This is fully half of a computer. A computer has just two parts, and this is one of them. So now you know half of what is inside a computer. Every part is made out of NAND gates. That wasn’t very difficult was it?  There is one problem here, and that is that 256 bytes is a very small size for a computer’s RAM. We may be able to get away with it in this book, but if you want a real computer, it’s going to need a RAM with many more bytes to choose from.  A larger RAM can be built by providing two registers that are used to select a memory storage location. This allows the use of 8X256 decoders, and results in a grid with 65,536 intersections, and thus a RAM with 65,536 different locations in which to store something.  Here’s an idea of what it would look like: (Don’t bother 67 trying to count the grid lines, it was only possible to fit about half of them on the printed page.) 68 69 A bus carries one byte at a time, so selecting one of the 65,536 memory locations of this RAM would be a twostep process. First, one byte would have to be placed on the ‘a’ bus and set into R0, then the second byte would have to be placed onto the ‘a’ bus and set into R1. Now you could access the desired memory location with the bus and the ‘s’ and ‘e’ bits at the bottom of the drawing.  Simplifying again, we have something that looks very much like our 256 byte RAM, it just has one more input bit.  For the rest of this book, we will be using the 256 byte RAM just to keep things simple. If you want to imagine a computer with a larger RAM, every time we send a byte to the Memory Address Register, all you have to do is imagine sending two bytes instead.  70 Numbers We are going to return to the subject of codes for a moment. Previously we looked at a code called ASCII that is used to represent written language. Well, numbers are used in written language too, so there are ASCII codes for the digits zero through nine. Earlier we saw 20 of the ASCII codes for part of the alphabet, here are 10 more, the codes for numbers in written language: 0 0011 0000 1 0011 0001 2 0011 0010 3 0011 0011 4 0011 0100 5 0011 0101 6 0011 0110 7 0011 0111 8 0011 1000 9 0011 1001 This is a very useful code, but not everything that computers do has to do with written language. For other tasks, there are other codes that are suited better to those tasks. When it comes to numbers, if you use ASCII, one byte can be any of the 10 digits from 0 to 9. But sometimes there is a byte that is always used to store a number, and that number will never be printed or displayed on the screen. In this case, we can use a different code that doesn’t waste any of its possible states on letters of the alphabet or anything other than numbers. Since a byte has 256 possible states, you can 71 have this code represent 256 different numbers. Since we want to include zero, this code starts at zero and goes up to 255.  Now how is this code arranged? The ASCII above is not used at all; this is a completely different code. This code did not require any committee meetings to invent because it is the simplest and most obvious code that computers use. It is the closest thing there is to a ‘natural’ computer code.  Since this is a long chapter, here is a preview of this code. It consists of assigning a numeric value to each bit in the byte. To use this code, just turn on the bits that add up to the number you want to represent.  To see how this code works, why it is used in computers, and how those bit values were chosen, we will examine the subject of numbers outside of computers.  There are three number systems that you are probably familiar with that we can analyze. As I see it, these three systems are each made up of two ideas or elements – first, a list of symbols, and second, a method for using those symbols.  Probably the oldest number system around is a simple thing called Tally Marks. It has two symbols, “|” and “/.” The method for using these symbols is that you write down a “|” for each of the first four things you are counting, then for the fifth mark, you write a “/” across the first four. You repeat this over and over as long as necessary and then when you’re done you count the marks by groups of five – 5, 10, 15, 20, etc. This system is very good for counting things as they pass by, say your flock of sheep. As each animal walks by, you just scratch down one more mark – you don’t have to cross out ‘6’ and write ‘7’. This system has another advantage in that there is actually one mark for each 72 thing that has been counted. Later in the chapter we are going to do some interesting things with numbers that may get confusing, so in order to keep things clear, we will make use of this old system.  Do you remember Roman numerals? It is a number system that also consists of two elements. The first element is the symbols, just selected letters from the alphabet, ‘I’ for one, ‘V’ for five, ‘X’ for ten, ‘L’ for fifty, ‘C’ for one hundred, ‘D’ for five hundred, ‘M’ for one thousand. The second element is a method that allows you to represent numbers that don’t have a single symbol.  The Roman method says that you write down multiple symbols, the largest ones first, and add them up, except when a smaller symbol is to left of a larger one, then you subtract it. So ‘II’ is two (add one and one,) and ‘IV’ is four (subtract one from five.) One of the things that made this author very happy about the coming of the year 2000 was the fact that Roman numerals representing the year got a lot simpler. 1999 was ‘MCMXCIX,’ you have to do three subtractions in your head just to read that one. 2000 was simply ‘MM.’ The normal number system we use today also consists of two ideas, but these are two very different ideas that came to us through Arabia rather than Rome. The first of these ideas is also about symbols, in this case 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9. These digits are symbols that represent a quantity. The second idea is a method that we are so used to, that we use it instinctively. This method says that if you write down one digit, it means what it says. If you write down two digits next to each other, the one on the right means what it says, but the one to its left means ten times what it says. If you write down three digits right next to each other, the one on the right means what it says, the middle one means ten times what it says and the one on the left means one hundred times what it says. When you want to express a number greater than 9, you do it by using multiple digits, and you use this method that says that the number of positions to the left of the first digit tells you how many times you multiply it by ten before you add them up. So, if you have ‘246’ apples, that means that you have two hundred apples plus forty apples plus six apples.  73 So how does this work? A number of any amount can be written with the digits zero through nine, but when you go higher than nine, you have to use two digits. When you go above ninety-nine, you have to use three digits.  Above nine hundred ninety-nine, you go to four digits, etc. If you are counting upwards, the numbers in any one of the positions go ‘round and ‘round - zero to nine, then zero to nine again, on and on, and whenever you go from nine back to zero, you increase the digit to the left by 1. So you only have ten symbols, but you can use more than one of them as needed and their positions with regard to each other specify their full value.  There is something odd about this in that the system is based on ten, but there is no single symbol for ten. On the other hand, there is something right about this – the symbols ‘0’ through ‘9’ do make up ten different symbols. If we also had a single symbol for ten, there would actually be eleven different symbols. So whoever thought of this was pretty smart.  One of the new ideas in this Arabic system was to have a symbol for zero. This is useful if you want to say that you have zero apples, but it is also a necessary thing to keep the positions of the digits straight. If you have 50 apples or 107 apples, you need the zeros in the numbers to know what position each digit is actually in, so you can multiply by ten the correct number of times.  Now these two ideas in the Arabic number system (the digits and the method) have one thing in common. They both have the number ten associated with them. There are ten different digits, and as you add digits to the left side of a number, each position is worth ten times more than the previous one.  In school, when they first teach children about numbers, they say something about our number system being based on the number ten, because we have ten fingers. So here’s an odd question: What if this number system had been invented by three-toed sloths? They only have three fingers on each hand, and no thumbs. They would have invented a number system with only six digits- 0, 1, 2, 3, 4 and 5. Could this work? If you had eight apples, how would you write it? There is no number ‘8’ in this system. The answer is, that since the first idea, the 74 digits, was changed to only have six digits, then the second idea, the method, would also have to be changed so that as you add positions to the left, each one would have to be multiplied by sixes instead of tens. Then this system would work. As you count your apples, you would say “0, 1, 2, 3, 4, 5…” and then what? There’s no ‘6’ for the next number. Well, according to the method, when you want to go beyond the highest digit, you go back to ‘0’ and add a ‘1’ to the left. OK, “0, 1, 2, 3, 4, 5, 10, 11, 12.” Now you have counted all of your apples. What would this ‘12’ mean? It would be this many: . I guess you’d call it eight, but you’d write it ‘12’. Very odd, but it does work out - 1 times six plus two equals eight apples, it follows the Arabic method, but it is based on six instead of ten. If you continued counting up, when you got to ‘15,’ which is (one times six plus five,) the next number would be ‘20,’ but the ‘2’ would mean two sixes, or this many: . And 55 would be followed by 100. The ‘1’ in that third position would be how many ‘36’s there were (six times six) This is a very odd number system, but guess what, you already use it in your everyday life. Yes, think of the way we write time, or the kind of clock that shows the numbers on its face. The right digit of the minutes and seconds follows our normal numbers, 0-9, 0-9, over and over. But the left digit of the minutes and seconds only goes 0-5. After 59 minutes, the clock goes to the next hour and 00 minutes. There are 60 minutes in an hour, numbered from 00 to 59. That left position never gets over 5. That position uses the number system based on six symbols (0-5). The hour part of the clock tells how many ‘60’s there are, though you will never see a 60 on the face of the clock. And you are so used to this that you don’t have to think about it. When the clock says 1:30, you know that this is halfway between 1:00 and 2:00, you don’t have to do any math in your head to figure it out. Have you ever had to add time? If you add 40 minutes and 40 minutes, you get 80 minutes, but to write that down in hours and minutes, you have to figure out how many 60s there are in 80, in this case 1, then figure out how many minutes there are beyond 60, in this 75 case 20. So you write 1:20. The 1 represents 60 minutes, add 20 and you have your 80 again. So this is pretty complicated, two different number systems in the same number! But you have already been using it your whole life.  The hour positions are even stranger. On a 12 hour clock, it skips zero and goes 1-12 AM, then 1-12 PM. On a 24 hour clock, it goes from 00-23. We won’t try to analyze these. The point we wanted to make was that you are already familiar with number systems based on numbers other than ten.  You could invent a number system for any amount of digits, 10 or 6 like we’ve seen above, or 3 or 14 or any number you choose. But the simplest one would be if you only had 2 digits, 0 and 1. How would this one work?  Well, you’d count 0, 1… and then you’re already out of digits – so back to 0 and add 1 on the left, making the next number 10 then 11, then you’re out of digits again, so 100 then 101, 110, 111 then 1000. This system is based on two, so there are only two digits, and as you add positions to the left, each one is worth two times more than the previous one. The right position means what it says, the next one to the left means two times what it says, the next means four times what it says, the next means eight times, etc. When you get down to only having two possible digits, you don’t have to do much multiplication to figure out the total value of a position. In the position that is worth ‘eight,’ for example, there can only be a one, meaning one ‘eight,’ or a zero, meaning ‘no eights.’ While we’re at it, let’s imagine a very strange animal with eight fingers on each hand. That animal would have invented numbers based on sixteen. In their system, they would be able to write ten through fifteen each with a 76 single symbol. Only when they arrived at sixteen would they get back around to 0 and need to put a 1 in the position to the left. To see how this would work, we need six new symbols, so let’s just use the first six letters of the alphabet. ‘A’ will mean ten, ‘B’ will mean eleven, ‘C’ will mean twelve, ‘D’ will mean thirteen, ‘E’ will mean fourteen and ‘F’ will mean fifteen. Only after using all sixteen symbols in the right position will we run out of symbols, and the next number will be sixteen, written ‘10’ in this system. If you’re familiar with the pounds and ounces system of weights, it’s sort of like this system. There are 16 ounces in a pound, so you know that 8 ounces is half a pound. Adding 9 ounces and 9 ounces comes out to 1 pound 2 ounces.  Here is a chart that shows five different number systems. The first column is the old tally mark system to keep it sensible.  77 Our normal 0-9 numbers are called the decimal system, because ‘dec’ means ten in some ancient language. The 0- 5 system would be called the senary system, because ‘sen’ means six in some other ancient language. This new 78 system with just 0 and 1 is called the binary system because ‘bi’ means two, also because of some ancient language. This other new system, the 0-F system, will be called the hexadecimal system, because ‘hex’ is another ancient word that means six and ‘dec’ still means ten, so it’s the six plus ten system.  Another method of naming different number systems is to call them by the number they are based on, such as ‘base 10’ or ‘base 2,’ etc. meaning decimal or binary, etc.  But notice that the number after the word ‘base’ is written in the decimal system. ‘2’ written in binary is ‘10,’ so ‘base 10’ would mean binary if the ‘10’ was written in binary. In fact, every number system would be ‘base 10’ if the ‘10’ was written in that system’s numbers! So we could talk about base 2, base 6, base 10 and base 16 if we wanted to, as long as we remember that those base numbers are written in decimal. If we talk about binary, senary, decimal and hexadecimal, it’s the same thing, just possibly a little less confusing.  Again, in our normal decimal numbers, the rightmost position is the number of ones. The next position to the left is the number of tens, etc. Each position is worth ten times the previous one. In the binary system, the rightmost position is also the number of ones, but the next position to the left is the number of ‘twos,’ the next to the left is the number of ‘fours,’ the next is ‘eights.’ Each position is worth two times the amount to its right. Since each position has only two possible values, zero or one, this is something that we could use in a byte.  This is the point of this chapter. The binary number system is a ‘natural’ match to the capabilities of computer parts. We can use it as a code, with off representing zero and on representing one, following the Arabic number method with only two symbols. In a byte, we have eight bits. When we use this code, the bit on the right will be worth 1 when the bit is on, or 0 when it is off. The next bit to the left will be worth 2 when it is on, or 0 when it is off. The next to the left is 4, and so on with 8, 16, 32, 64 and 128. In the order we normally see them, the values of the eight bits look like this: 128 64 32 16 8 4 2 1.  79 In this code, 0000 0001 means one, 0001 0000 means sixteen, 0001 0001 means seventeen (sixteen plus one,) 1111 1111 means 255, etc. In an eight-bit byte, we can represent a number anywhere from 0 to 255. This code is called the “binary number code.” The computer works just fine with this arrangement, but it is annoying for people to use. Just saying what is in a byte is a problem. If you have 0000 0010, you can call it “zero zero zero zero zero zero one zero binary” or you can mentally translate it to decimal and call it “two,” and that is usually what is done. In this book when a number is spelled out, such as ‘twelve,’ it means 12 in our decimal system. A binary 0000 0100 would be called ‘four,’ because that is what it works out to be in decimal.  Actually, in the computer industry, people often use hexadecimal, (and they just call it ‘hex’.) If you look at the chart above, you can see that four digits of binary can be expressed by one digit of hex. If you have a byte containing 0011 1100, you can translate it to 60 decimal, or just call it “3C hex.” Now don’t worry, we’re not going to use hex in this book, but you may have seen these types of numbers somewhere, and now you know what that was all about.  80 Addresses Now that we have the binary number code, we can use it for various purposes in our computer. One of the first places we will use it, is in the Memory Address Register. The pattern of bits that we put into this register will use the binary number code. The bits of this number in MAR then select one of the 256 RAM storage locations. The number in MAR is considered to be a number somewhere between 0 and 255, and thus each of the 256 RAM bytes can be considered to have an address.  This is fairly simple, but a point needs to be made here about exactly what is meant by an address inside of a computer. In a neighborhood of homes, each house has an address, like 125 Maple Street. There is a sign at the corner that says “Maple St.” and written on the house are the numerals “125.” This is the way we normally think of addresses. The point to be made here is that the houses and streets have numbers or names written on them. In the computer, the byte does not have any identifying information on it or contained in it. It is simply the byte that gets selected when you put that number in the Memory Address Register. The byte gets selected by virtue of where it is, not by any other factor that is contained at that location. Imagine a neighborhood of houses that had sixteen streets, and sixteen houses on each street. Imagine that the streets do not have signs and the houses do not have numbers written on them. You would still be able to find any specific house if you were told, for example, to go to ‘the fourth house on the seventh street.’ That house still has an address, that is, a method of locating it, it just doesn’t have any identifying information at the location. So a computer address is just a number that causes a certain byte to be selected when that address is placed into the Memory Address Register.  81 The Other Half of the Computer The other half of the computer is also made ultimately of nothing but NAND gates, and it probably has fewer total parts than the RAM we have built, but it is not laid out so regularly and repetitively, so it will take a little longer to explain. We will call this half of the computer the “Central Processing Unit,” or CPU for short, because it does something with and to the bytes in RAM. It “processes” them, and we will see what that means in the next few chapters. The thing that is common to both sides of the computer is the bus.  Here are the beginnings of the CPU. The RAM is shown on the right, and the bus makes a big loop between the two bus connections on the RAM. The CPU starts with six 82 registers connected to the bus. These six registers are all of the places that the CPU will use to “process” bytes. That’s not so complicated, is it?  The big box labeled “Control Section” in the middle of the diagram will be examined in detail later. It controls all of the ‘set’ and ‘enable’ bits in the CPU and the RAM. The boxes with the question marks will be explained immediately following this chapter. For now, we are going to look at where the bytes can go within the CPU.  R0, R1, R2, and R3 are registers that are used as shortterm storage for bytes that are needed in the CPU. Their inputs and outputs are connected to the bus. They can be used for many different purposes, so they are known as “general purpose registers.” The register called ‘TMP’ means temporary. Its input comes from the bus, and its output goes downward to one and then the other of the question marked boxes. TMP has a ‘set’ bit, but no ‘enable’ bit because we never have a reason to turn its output off.  The last register is called the accumulator, or ACC for short. This is a word that comes from the days of the old mechanical adding machines (pre 1970.) I guess it meant that as you added up a column of numbers, it would ‘accumulate’ a running total. In a computer, it just means that it temporarily stores a byte that comes from that big question marked box. The output of ACC is then connected to our old friend, the bus, so it can be sent somewhere else as needed.  The registers in the CPU and RAM are the places where the contents of bytes come from and go to as the computer operates. All movements involve enabling one register onto the bus, and setting the contents of the bus into another register.  Now we will look at what is in those boxes with the question marks.  83 More Gates We have used NAND, AND and NOT gates so far. There are two more combination gates that we need to define. The first is built like this: All it does is to NOT the two inputs to one of our good old NAND gates. Here is the chart for it, showing the intermediate wires so it is easy to follow.  a b c d e 0 0 1 1 0 0 1 1 0 1 1 0 0 1 1 1 1 0 0 1 In this case, when both inputs are off, the output is off, but if either ‘a’ OR ‘b’ is on, or both, then the output will be on. So it has another very simple name, it is called the “OR gate.” Instead of drawing all the parts, it has its own diagram shaped something like a shield. The diagram and chart look like this: a b c 0 0 0 0 1 1 84 1 0 1 1 1 1 Like the AND gate, you can build OR gates with more than two inputs. Just add another OR gate in place of one of the inputs, and you will then have three inputs, any one of which will turn the output on. Also like the AND gate, every time you add an input, the number of lines on the chart will double. With the OR gate, only the line that has all inputs off will have the output off.  All the rest of the lines will show the output being on.  The last combination gate we need here takes five gates to make, but what it ultimately does is quite simple.  Similar to the OR gate, the output is on when either input is on, but in this version, the output goes back off if both inputs are on. So it is called an Exclusive OR gate, or XOR gate for short. The output is on if either OR the other input is on, exclusively. Only if it is OR, not if it is AND. Another way to look it at it is the output comes on if one and only one input is on.  Still another way to look at it is the output is off if the inputs are the same, and on if the inputs are different.  a b c d e f g 0 0 1 1 1 1 0 85 0 1 1 0 0 1 1 1 0 0 1 1 0 1 1 1 0 0 1 1 0 The simplified diagram looks similar to an OR gate, but it has a double curved line on the input side. The diagram and chart look like this: a b c 0 0 0 0 1 1 1 0 1 1 1 0 We now have four kinds of gates that take two inputs and make one output. They are NAND, AND, OR and XOR. Here is a chart that makes it pretty simple: 86 For the four possible input combinations of ‘a’ and ‘b,’ each type of gate has its own set of output states, and the names of the gates can help you remember which is which.  In spite of the fact that everything in the computer is made out of NAND gates, we are not going to be using any NAND gates by themselves in this computer! Now that we have used them to build AND, OR, XOR and NOT gates, and the memory bit, we are done with the NAND gate. Thank you Mr. NAND gate, bye bye for now.  87 Messing with Bytes Individual gates operate on bits. Two bits in, one bit out. But the RAM stores and retrieves a byte at a time.  And the bus moves a byte at a time. Here in the CPU, we want to be able to work on a whole byte at one time. We want some ‘gates’ that affect an entire byte. In the chapter on the bus, we saw how the contents of a byte can be copied from one register to another. This is usually referred to as moving a byte. Now we are going to see some variations on this.  First we will see three ways that we can change the contents of a byte as it moves from one register to another. Second, we will see four ways that we can take the contents of two bytes, and have them interact with each other to create the contents for a third byte.  These are all of the things that computers actually do to bytes. All things ultimately come down to these seven operations.  88 The Left and Right Shifters The shifter is very easy to build. It doesn’t use any gates at all, it just wires up the bus a bit oddly. It is done like this: This shows two registers connected by a right shifter.  The shifter is just the wires between the two registers.  When the ‘e’ bit of R1 is turned on, and the ‘s’ bit of R2 is turned on and then off, all of the bits in R1 are copied into R2, but they are shifted over one position.  The one at the bottom (shift out) can be connected to some other bit in the computer, but is often connected back to the one on the top (shift in) and when that is done, the rightmost bit wraps around to the leftmost bit at the other end of the byte.  A right shifter will change 0100 0010, to 0010 0001.  If ‘shift out’ is connected to ‘shift in,’ a right shift will change 0001 1001 to 1000 1100 A left shifter will change 0100 0010 to 1000 0100. The 89 left shifter is wired up like so: Once again, we have bus versions of these drawings. They each have an ‘i’ and ‘o’ bus, and also one input and output bit, like this: Now of what use is this? The minds of programmers have come up with all sorts of things, but here is an interesting one. Assume that you are using the binary number code. You have the number 0000 0110 in R1. That comes out to the decimal number 6. Now shift that code left into R2. R2 will then be 0000 1100. This comes out to the decimal number 12. What do you know, we have just 90 multiplied the number by 2. This is the basis of how multiplication is done in our computer. How you multiply by something other than 2 will be seen later, but this is how simple it is, just shift the bits. This is similar to something we do with decimal numbers. If you want to multiply something by ten, you just add a zero to the right side, effectively shifting each digit left one position. In the binary system, this only results in multiplying by two because two is what the system is based on.  So that’s the shifter, no gates at all.
